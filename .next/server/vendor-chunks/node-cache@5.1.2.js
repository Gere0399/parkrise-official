/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-cache@5.1.2";
exports.ids = ["vendor-chunks/node-cache@5.1.2"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/index.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var exports;\n\n  exports = module.exports = __webpack_require__(/*! ./lib/node_cache */ \"(rsc)/./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/lib/node_cache.js\");\n\n  exports.version = '5.1.2';\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbm9kZS1jYWNoZUA1LjEuMi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVkscUpBQTRDOztBQUV4RDs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJEOlxcUHJvamVjdHNcXG9uZ29pbmdcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG5vZGUtY2FjaGVANS4xLjJcXG5vZGVfbW9kdWxlc1xcbm9kZS1jYWNoZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIG5vZGUtY2FjaGUgNS4xLjIgKCAyMDIwLTA3LTAxIClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGVcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1haW50YWluZWQgYnkgICggIClcbiovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBleHBvcnRzO1xuXG4gIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL25vZGVfY2FjaGUnKTtcblxuICBleHBvcnRzLnZlcnNpb24gPSAnNS4xLjInO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/lib/node_cache.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/lib/node_cache.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = __webpack_require__(/*! clone */ \"(rsc)/./node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js\");\n\n  EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbm9kZS1jYWNoZUA1LjEuMi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9saWIvbm9kZV9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMENBQTBDLHFFQUFxRTtBQUN4Szs7QUFFQSxVQUFVLG1CQUFPLENBQUMsaUZBQU87O0FBRXpCLGlCQUFpQiwwREFBOEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJEOlxcUHJvamVjdHNcXG9uZ29pbmdcXG5vZGVfbW9kdWxlc1xcLnBucG1cXG5vZGUtY2FjaGVANS4xLjJcXG5vZGVfbW9kdWxlc1xcbm9kZS1jYWNoZVxcbGliXFxub2RlX2NhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBub2RlLWNhY2hlIDUuMS4yICggMjAyMC0wNy0wMSApXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1jYWNoZS9ub2RlLWNhY2hlXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1jYWNoZS9ub2RlLWNhY2hlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBNYWludGFpbmVkIGJ5ICAoICApXG4qL1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgRXZlbnRFbWl0dGVyLCBOb2RlQ2FjaGUsIGNsb25lLFxuICAgIHNwbGljZSA9IFtdLnNwbGljZSxcbiAgICBib3VuZE1ldGhvZENoZWNrID0gZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBFcnJvcignQm91bmQgaW5zdGFuY2UgbWV0aG9kIGFjY2Vzc2VkIGJlZm9yZSBiaW5kaW5nJyk7IH0gfSxcbiAgICBpbmRleE9mID0gW10uaW5kZXhPZjtcblxuICBjbG9uZSA9IHJlcXVpcmUoXCJjbG9uZVwiKTtcblxuICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbiAgLy8gZ2VuZXJhdGUgc3VwZXJjbGFzc1xuICBtb2R1bGUuZXhwb3J0cyA9IE5vZGVDYWNoZSA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBOb2RlQ2FjaGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vICMjIGdldFxuXG4gICAgICAgIC8vIGdldCBhIGNhY2hlZCBrZXkgYW5kIGNoYW5nZSB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleVxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLmdldCBcIm15S2V5XCIsICggZXJyLCB2YWwgKVxuXG4gICAgICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgbWdldFxuXG4gICAgICAgIC8vIGdldCBtdWx0aXBsZSBjYWNoZWQga2V5cyBhdCBvbmNlIGFuZCBjaGFuZ2UgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5c2AgKCBTdHJpbmd8TnVtYmVyW10gKTogYW4gYXJyYXkgb2Yga2V5c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLm1nZXQgWyBcImZvb1wiLCBcImJhclwiIF1cblxuICAgICAgICB0aGlzLm1nZXQgPSB0aGlzLm1nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgc2V0XG5cbiAgICAgICAgLy8gc2V0IGEgY2FjaGVkIGtleSBhbmQgY2hhbmdlIHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5XG4gICAgICAgIC8vICogYHZhbHVlYCAoIEFueSApOiBBIGVsZW1lbnQgdG8gY2FjaGUuIElmIHRoZSBvcHRpb24gYG9wdGlvbi5mb3JjZVN0cmluZ2AgaXMgYHRydWVgIHRoZSBtb2R1bGUgdHJ5cyB0byB0cmFuc2xhdGUgaXQgdG8gYSBzZXJpYWxpemVkIEpTT05cbiAgICAgICAgLy8gKiBgWyB0dGwgXWAgKCBOdW1iZXIgfCBTdHJpbmcgKTogKCBvcHRpb25hbCApIFRoZSB0aW1lIHRvIGxpdmUgaW4gc2Vjb25kcy5cblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5zZXQgXCJteUtleVwiLCBcIm15X1N0cmluZyBWYWx1ZVwiXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuc2V0IFwibXlLZXlcIiwgXCJteV9TdHJpbmcgVmFsdWVcIiwgMTBcblxuICAgICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICAvLyAjIyBtc2V0XG5cbiAgICAgICAgLy8gc2V0IG11bHRpcGxlIGtleXMgYXQgb25jZVxuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleVZhbHVlU2V0YCAoIE9iamVjdFtdICk6IGFuIGFycmF5IG9mIG9iamVjdCB3aGljaCBpbmNsdWRlcyBrZXksdmFsdWUgYW5kIHR0bFxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLm1zZXQoXG4gICAgICAgIC8vXHRcdFtcbiAgICAgICAgLy9cdFx0XHR7XG4gICAgICAgIC8vXHRcdFx0XHRrZXk6IFwibXlLZXlcIixcbiAgICAgICAgLy9cdFx0XHRcdHZhbDogXCJteVZhbHVlXCIsXG4gICAgICAgIC8vXHRcdFx0XHR0dGw6IFt0dGwgaW4gc2Vjb25kc11cbiAgICAgICAgLy9cdFx0XHR9XG4gICAgICAgIC8vXHRcdF0pXG5cbiAgICAgICAgdGhpcy5tc2V0ID0gdGhpcy5tc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGRlbFxuXG4gICAgICAgIC8vIHJlbW92ZSBrZXlzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5c2AgKCBTdHJpbmcgfMKgTnVtYmVyIHwgU3RyaW5nfE51bWJlcltdICk6IGNhY2hlIGtleSB0byBkZWxldGUgb3IgYSBhcnJheSBvZiBjYWNoZSBrZXlzXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggTnVtYmVyICk6IE51bWJlciBvZiBkZWxldGVkIGtleXNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5kZWwoIFwibXlLZXlcIiApXG5cbiAgICAgICAgdGhpcy5kZWwgPSB0aGlzLmRlbC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyB0YWtlXG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjYWNoZWQgdmFsdWUgYW5kIHJlbW92ZSB0aGUga2V5IGZyb20gdGhlIGNhY2hlLlxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYGdldChrZXkpYCArIGBkZWwoa2V5KWAuXG4gICAgICAgIC8vIFVzZWZ1bCBmb3IgaW1wbGVtZW50aW5nIGBzaW5nbGUgdXNlYCBtZWNoYW5pc20gc3VjaCBhcyBPVFAsIHdoZXJlIG9uY2UgYSB2YWx1ZSBpcyByZWFkIGl0IHdpbGwgYmVjb21lIG9ic29sZXRlLlxuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5XG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUudGFrZSBcIm15S2V5XCIsICggZXJyLCB2YWwgKVxuXG4gICAgICAgIHRoaXMudGFrZSA9IHRoaXMudGFrZS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyB0dGxcblxuICAgICAgICAvLyByZXNldCBvciByZWRlZmluZSB0aGUgdHRsIG9mIGEga2V5LiBgdHRsYCA9IDAgbWVhbnMgaW5maW5pdGUgbGlmZXRpbWUuXG4gICAgICAgIC8vIElmIGB0dGxgIGlzIG5vdCBwYXNzZWQgdGhlIGRlZmF1bHQgdHRsIGlzIHVzZWQuXG4gICAgICAgIC8vIElmIGB0dGxgIDwgMCB0aGUga2V5IHdpbGwgYmUgZGVsZXRlZC5cblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleSB0byByZXNldCB0aGUgdHRsIHZhbHVlXG4gICAgICAgIC8vICogYHR0bGAgKCBOdW1iZXIgKTogKCBvcHRpb25hbCAtPiBvcHRpb25zLnN0ZFRUTCB8fCAwICkgVGhlIHRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggQm9vbGVuICk6IGtleSBmb3VuZCBhbmQgdHRsIHNldFxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnR0bCggXCJteUtleVwiICkgLy8gd2lsbCBzZXQgdHRsIHRvIGRlZmF1bHQgdHRsXG5cbiAgICAgICAgLy9cdG15Q2FjaGUudHRsKCBcIm15S2V5XCIsIDEwMDAgKVxuXG4gICAgICAgIHRoaXMudHRsID0gdGhpcy50dGwuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZ2V0VHRsXG5cbiAgICAgICAgLy8gcmVjZWl2ZSB0aGUgdHRsIG9mIGEga2V5LlxuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5IHRvIGNoZWNrIHRoZSB0dGwgdmFsdWVcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBOdW1iZXJ8dW5kZWZpbmVkICk6IFRoZSB0aW1lc3RhbXAgaW4gbXMgd2hlbiB0aGUga2V5IHdpbGwgZXhwaXJlLCAwIGlmIGl0IHdpbGwgbmV2ZXIgZXhwaXJlIG9yIHVuZGVmaW5lZCBpZiBpdCBub3QgZXhpc3RzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuZ2V0VHRsKCBcIm15S2V5XCIgKVxuXG4gICAgICAgIHRoaXMuZ2V0VHRsID0gdGhpcy5nZXRUdGwuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMga2V5c1xuXG4gICAgICAgIC8vIGxpc3QgYWxsIGtleXMgd2l0aGluIHRoaXMgY2FjaGVcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBBcnJheSApOiBBbiBhcnJheSBvZiBhbGwga2V5c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBfa2V5cyA9IG15Q2FjaGUua2V5cygpXG5cbiAgICAgICAgLy8gICAgICMgWyBcImZvb1wiLCBcImJhclwiLCBcImZpenpcIiwgXCJidXp6XCIsIFwiYW5vdGhlcktleXNcIiBdXG5cbiAgICAgICAgdGhpcy5rZXlzID0gdGhpcy5rZXlzLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGhhc1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEga2V5IGlzIGNhY2hlZFxuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5IHRvIGNoZWNrIHRoZSB0dGwgdmFsdWVcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBCb29sZWFuICk6IEEgYm9vbGVhbiB0aGF0IGluZGljYXRlcyBpZiB0aGUga2V5IGlzIGNhY2hlZFxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBfZXhpc3RzID0gbXlDYWNoZS5oYXMoJ215S2V5JylcblxuICAgICAgICAvLyAgICAgIyB0cnVlXG5cbiAgICAgICAgdGhpcy5oYXMgPSB0aGlzLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBnZXRTdGF0c1xuXG4gICAgICAgIC8vIGdldCB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAtXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggT2JqZWN0ICk6IFN0YXRzIGRhdGFcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5nZXRTdGF0cygpXG4gICAgICAgIC8vICAgICAjIHtcbiAgICAgICAgLy8gICAgICMgaGl0czogMCxcbiAgICAgICAgLy8gICAgICMgbWlzc2VzOiAwLFxuICAgICAgICAvLyAgICAgIyBrZXlzOiAwLFxuICAgICAgICAvLyAgICAgIyBrc2l6ZTogMCxcbiAgICAgICAgLy8gICAgICMgdnNpemU6IDBcbiAgICAgICAgLy8gICAgICMgfVxuXG4gICAgICAgIHRoaXMuZ2V0U3RhdHMgPSB0aGlzLmdldFN0YXRzLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGZsdXNoQWxsXG5cbiAgICAgICAgLy8gZmx1c2ggdGhlIHdob2xlIGRhdGEgYW5kIHJlc2V0IHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmZsdXNoQWxsKClcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5nZXRTdGF0cygpXG4gICAgICAgIC8vICAgICAjIHtcbiAgICAgICAgLy8gICAgICMgaGl0czogMCxcbiAgICAgICAgLy8gICAgICMgbWlzc2VzOiAwLFxuICAgICAgICAvLyAgICAgIyBrZXlzOiAwLFxuICAgICAgICAvLyAgICAgIyBrc2l6ZTogMCxcbiAgICAgICAgLy8gICAgICMgdnNpemU6IDBcbiAgICAgICAgLy8gICAgICMgfVxuXG4gICAgICAgIHRoaXMuZmx1c2hBbGwgPSB0aGlzLmZsdXNoQWxsLmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICAvLyAjIyBmbHVzaFN0YXRzXG5cbiAgICAgICAgLy8gZmx1c2ggdGhlIHN0YXRzIGFuZCByZXNldCBhbGwgY291bnRlcnMgdG8gMFxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmZsdXNoU3RhdHMoKVxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmdldFN0YXRzKClcbiAgICAgICAgLy8gICAgICMge1xuICAgICAgICAvLyAgICAgIyBoaXRzOiAwLFxuICAgICAgICAvLyAgICAgIyBtaXNzZXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtleXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtzaXplOiAwLFxuICAgICAgICAvLyAgICAgIyB2c2l6ZTogMFxuICAgICAgICAvLyAgICAgIyB9XG5cbiAgICAgICAgdGhpcy5mbHVzaFN0YXRzID0gdGhpcy5mbHVzaFN0YXRzLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGNsb3NlXG5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGNsZWFyIHRoZSBpbnRlcnZhbCB0aW1lb3V0IHdoaWNoIGlzIHNldCBvbiBjaGVja3BlcmlvZCBvcHRpb24uXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuY2xvc2UoKVxuXG4gICAgICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9jaGVja0RhdGFcblxuICAgICAgICAvLyBpbnRlcm5hbCBob3VzZWtlZXBpbmcgbWV0aG9kLlxuICAgICAgICAvLyBDaGVjayBhbGwgdGhlIGNhY2hlZCBkYXRhIGFuZCBkZWxldGUgdGhlIGludmFsaWQgdmFsdWVzXG4gICAgICAgIHRoaXMuX2NoZWNrRGF0YSA9IHRoaXMuX2NoZWNrRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfY2hlY2tcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdGhlIGNoZWNrIHRoZSB2YWx1ZS4gSWYgaXQncyBub3QgdmFsaWQgYW55IG1vcmUgZGVsZXRlIGl0XG4gICAgICAgIHRoaXMuX2NoZWNrID0gdGhpcy5fY2hlY2suYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2lzSW52YWxpZEtleVxuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBjaGVjayBpZiB0aGUgdHlwZSBvZiBhIGtleSBpcyBlaXRoZXIgYG51bWJlcmAgb3IgYHN0cmluZ2BcbiAgICAgICAgdGhpcy5faXNJbnZhbGlkS2V5ID0gdGhpcy5faXNJbnZhbGlkS2V5LmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF93cmFwXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIHdyYXAgYSB2YWx1ZSBpbiBhbiBvYmplY3Qgd2l0aCBzb21lIG1ldGFkYXRhXG4gICAgICAgIHRoaXMuX3dyYXAgPSB0aGlzLl93cmFwLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9nZXRWYWxMZW5ndGhcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gY2FsY3VsYXRlIHRoZSB2YWx1ZSBsZW5ndGhcbiAgICAgICAgdGhpcy5fZ2V0VmFsTGVuZ3RoID0gdGhpcy5fZ2V0VmFsTGVuZ3RoLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9lcnJvclxuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBoYW5kbGUgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICB0aGlzLl9lcnJvciA9IHRoaXMuX2Vycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9pbml0RXJyb3JzXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGdlbmVyYXRlIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGVzXG4gICAgICAgIHRoaXMuX2luaXRFcnJvcnMgPSB0aGlzLl9pbml0RXJyb3JzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2luaXRFcnJvcnMoKTtcbiAgICAgICAgLy8gY29udGFpbmVyIGZvciBjYWNoZWQgZGF0YVxuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgLy8gbW9kdWxlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgLy8gY29udmVydCBhbGwgZWxlbWVudHMgdG8gc3RyaW5nXG4gICAgICAgICAgZm9yY2VTdHJpbmc6IGZhbHNlLFxuICAgICAgICAgIC8vIHVzZWQgc3RhbmRhcmQgc2l6ZSBmb3IgY2FsY3VsYXRpbmcgdmFsdWUgc2l6ZVxuICAgICAgICAgIG9iamVjdFZhbHVlU2l6ZTogODAsXG4gICAgICAgICAgcHJvbWlzZVZhbHVlU2l6ZTogODAsXG4gICAgICAgICAgYXJyYXlWYWx1ZVNpemU6IDQwLFxuICAgICAgICAgIC8vIHN0YW5kYXJkIHRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzLiAwID0gaW5maW5pdHk7XG4gICAgICAgICAgc3RkVFRMOiAwLFxuICAgICAgICAgIC8vIHRpbWUgaW4gc2Vjb25kcyB0byBjaGVjayBhbGwgZGF0YSBhbmQgZGVsZXRlIGV4cGlyZWQga2V5c1xuICAgICAgICAgIGNoZWNrcGVyaW9kOiA2MDAsXG4gICAgICAgICAgLy8gZW4vZGlzYWJsZSBjbG9uaW5nIG9mIHZhcmlhYmxlcy4gSWYgYHRydWVgIHlvdSdsbCBnZXQgYSBjb3B5IG9mIHRoZSBjYWNoZWQgdmFyaWFibGUuIElmIGBmYWxzZWAgeW91J2xsIHNhdmUgYW5kIGdldCBqdXN0IHRoZSByZWZlcmVuY2VcbiAgICAgICAgICB1c2VDbG9uZXM6IHRydWUsXG4gICAgICAgICAgLy8gd2hldGhlciB2YWx1ZXMgc2hvdWxkIGJlIGRlbGV0ZWQgYXV0b21hdGljYWxseSBhdCBleHBpcmF0aW9uXG4gICAgICAgICAgZGVsZXRlT25FeHBpcmU6IHRydWUsXG4gICAgICAgICAgLy8gZW5hYmxlIGxlZ2FjeSBjYWxsYmFja3NcbiAgICAgICAgICBlbmFibGVMZWdhY3lDYWxsYmFja3M6IGZhbHNlLFxuICAgICAgICAgIC8vIG1heCBhbW91bnQgb2Yga2V5cyB0aGF0IGFyZSBiZWluZyBzdG9yZWRcbiAgICAgICAgICBtYXhLZXlzOiAtMVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAvLyBnZW5lcmF0ZSBmdW5jdGlvbnMgd2l0aCBjYWxsYmFja3MgKGxlZ2FjeSlcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVMZWdhY3lDYWxsYmFja3MpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HISBub2RlLWNhY2hlIGxlZ2FjeSBjYWxsYmFjayBzdXBwb3J0IHdpbGwgZHJvcCBpbiB2Ni54XCIpO1xuICAgICAgICAgIFtcImdldFwiLCBcIm1nZXRcIiwgXCJzZXRcIiwgXCJkZWxcIiwgXCJ0dGxcIiwgXCJnZXRUdGxcIiwgXCJrZXlzXCIsIFwiaGFzXCJdLmZvckVhY2goKG1ldGhvZEtleSkgPT4ge1xuICAgICAgICAgICAgdmFyIG9sZE1ldGhvZDtcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSByZWFsIGZ1bmN0aW9uXG4gICAgICAgICAgICBvbGRNZXRob2QgPSB0aGlzW21ldGhvZEtleV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZEtleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgICAgICAgIHZhciBjYiwgZXJyLCByZWYsIHJlcztcbiAgICAgICAgICAgICAgcmVmID0gYXJncywgWy4uLmFyZ3NdID0gcmVmLCBbY2JdID0gc3BsaWNlLmNhbGwoYXJncywgLTEpO1xuICAgICAgICAgICAgICAvLyByZXR1cm4gYSBjYWxsYmFjayBpZiBjYiBpcyBkZWZpbmVkIGFuZCBhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICByZXMgPSBvbGRNZXRob2QoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICBjYihudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgICAgICAgZXJyID0gZXJyb3IxO1xuICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZE1ldGhvZCguLi5hcmdzLCBjYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhdGlzdGljcyBjb250YWluZXJcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICBrZXlzOiAwLFxuICAgICAgICAgIGtzaXplOiAwLFxuICAgICAgICAgIHZzaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIC8vIHByZSBhbGxvY2F0ZSB2YWxpZCBrZXl0eXBlcyBhcnJheVxuICAgICAgICB0aGlzLnZhbGlkS2V5VHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl07XG4gICAgICAgIC8vIGluaXRhbGl6ZSBjaGVja2luZyBwZXJpb2RcbiAgICAgICAgdGhpcy5fY2hlY2tEYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZ2V0KGtleSkge1xuICAgICAgICB2YXIgX3JldCwgZXJyO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBkYXRhIGFuZCBpbmNyZW1ldCBzdGF0c1xuICAgICAgICBpZiAoKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0cy5oaXRzKys7XG4gICAgICAgICAgX3JldCA9IHRoaXMuX3Vud3JhcCh0aGlzLmRhdGFba2V5XSk7XG4gICAgICAgICAgLy8gcmV0dXJuIGRhdGFcbiAgICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBub3QgZm91bmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgIHRoaXMuc3RhdHMubWlzc2VzKys7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZ2V0KGtleXMpIHtcbiAgICAgICAgdmFyIF9lcnIsIGVyciwgaSwga2V5LCBsZW4sIG9SZXQ7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY29udmVydCBhIHN0cmluZyB0byBhbiBhcnJheSBvZiBvbmUga2V5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgIF9lcnIgPSB0aGlzLl9lcnJvcihcIkVLRVlTVFlQRVwiKTtcbiAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSByZXR1cm5cbiAgICAgICAgb1JldCA9IHt9O1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGdldCBkYXRhIGFuZCBpbmNyZW1lbnQgc3RhdHNcbiAgICAgICAgICBpZiAoKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmhpdHMrKztcbiAgICAgICAgICAgIG9SZXRba2V5XSA9IHRoaXMuX3Vud3JhcCh0aGlzLmRhdGFba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBmb3VuZCByZXR1cm4gYSBlcnJvclxuICAgICAgICAgICAgdGhpcy5zdGF0cy5taXNzZXMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGFsbCBmb3VuZCBrZXlzXG4gICAgICAgIHJldHVybiBvUmV0O1xuICAgICAgfVxuXG4gICAgICBzZXQoa2V5LCB2YWx1ZSwgdHRsKSB7XG4gICAgICAgIHZhciBfZXJyLCBlcnIsIGV4aXN0ZW50O1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGNhY2hlIGlzIG92ZXJmbG93aW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4S2V5cyA+IC0xICYmIHRoaXMuc3RhdHMua2V5cyA+PSB0aGlzLm9wdGlvbnMubWF4S2V5cykge1xuICAgICAgICAgIF9lcnIgPSB0aGlzLl9lcnJvcihcIkVDQUNIRUZVTExcIik7XG4gICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JjZSB0aGUgZGF0YSB0byBzdHJpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZVN0cmluZyAmJiAhdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgdHRsIGlmIG5vdCBwYXNzZWRcbiAgICAgICAgaWYgKHR0bCA9PSBudWxsKSB7XG4gICAgICAgICAgdHRsID0gdGhpcy5vcHRpb25zLnN0ZFRUTDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnRlcm5hbCBoZWxwZXIgdmFyaWFibGVzXG4gICAgICAgIGV4aXN0ZW50ID0gZmFsc2U7XG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyBkYXRhIGZyb20gc3RhdHNcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtrZXldKSB7XG4gICAgICAgICAgZXhpc3RlbnQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhdHMudnNpemUgLT0gdGhpcy5fZ2V0VmFsTGVuZ3RoKHRoaXMuX3Vud3JhcCh0aGlzLmRhdGFba2V5XSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gdGhpcy5fd3JhcCh2YWx1ZSwgdHRsKTtcbiAgICAgICAgdGhpcy5zdGF0cy52c2l6ZSArPSB0aGlzLl9nZXRWYWxMZW5ndGgodmFsdWUpO1xuICAgICAgICAvLyBvbmx5IGFkZCB0aGUga2V5cyBhbmQga2V5LXNpemUgaWYgdGhlIGtleSBpcyBuZXdcbiAgICAgICAgaWYgKCFleGlzdGVudCkge1xuICAgICAgICAgIHRoaXMuc3RhdHMua3NpemUgKz0gdGhpcy5fZ2V0S2V5TGVuZ3RoKGtleSk7XG4gICAgICAgICAgdGhpcy5zdGF0cy5rZXlzKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwic2V0XCIsIGtleSwgdmFsdWUpO1xuICAgICAgICAvLyByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbXNldChrZXlWYWx1ZVNldCkge1xuICAgICAgICB2YXIgX2VyciwgZXJyLCBpLCBqLCBrZXksIGtleVZhbHVlUGFpciwgbGVuLCBsZW4xLCB0dGwsIHZhbDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBjaGVjayBpZiBjYWNoZSBpcyBvdmVyZmxvd2luZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1heEtleXMgPiAtMSAmJiB0aGlzLnN0YXRzLmtleXMgKyBrZXlWYWx1ZVNldC5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heEtleXMpIHtcbiAgICAgICAgICBfZXJyID0gdGhpcy5fZXJyb3IoXCJFQ0FDSEVGVUxMXCIpO1xuICAgICAgICAgIHRocm93IF9lcnI7XG4gICAgICAgIH1cblxuLy8gbG9vcCBvdmVyIGtleVZhbHVlU2V0IHRvIHZhbGlkYXRlIGtleSBhbmQgdHRsXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleVZhbHVlU2V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAga2V5VmFsdWVQYWlyID0ga2V5VmFsdWVTZXRbaV07XG4gICAgICAgICAgKHtrZXksIHZhbCwgdHRsfSA9IGtleVZhbHVlUGFpcik7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgdHRsIGFuZCBpdCdzIGEgbnVtYmVyXG4gICAgICAgICAgaWYgKHR0bCAmJiB0eXBlb2YgdHRsICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBfZXJyID0gdGhpcy5fZXJyb3IoXCJFVFRMVFlQRVwiKTtcbiAgICAgICAgICAgIHRocm93IF9lcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IGtleVZhbHVlU2V0Lmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgIGtleVZhbHVlUGFpciA9IGtleVZhbHVlU2V0W2pdO1xuICAgICAgICAgICh7a2V5LCB2YWwsIHR0bH0gPSBrZXlWYWx1ZVBhaXIpO1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsLCB0dGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBkZWwoa2V5cykge1xuICAgICAgICB2YXIgZGVsQ291bnQsIGVyciwgaSwga2V5LCBsZW4sIG9sZFZhbDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBjb252ZXJ0IGtleXMgdG8gYW4gYXJyYXkgb2YgaXRzZWxmXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgIGtleXMgPSBba2V5c107XG4gICAgICAgIH1cbiAgICAgICAgZGVsQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9ubHkgZGVsZXRlIGlmIGV4aXN0ZW50XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNhbGMgdGhlIHN0YXRzXG4gICAgICAgICAgICB0aGlzLnN0YXRzLnZzaXplIC09IHRoaXMuX2dldFZhbExlbmd0aCh0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0sIGZhbHNlKSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmtzaXplIC09IHRoaXMuX2dldEtleUxlbmd0aChrZXkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0cy5rZXlzLS07XG4gICAgICAgICAgICBkZWxDb3VudCsrO1xuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XG4gICAgICAgICAgICAvLyByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVsXCIsIGtleSwgb2xkVmFsLnYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsQ291bnQ7XG4gICAgICB9XG5cbiAgICAgIHRha2Uoa2V5KSB7XG4gICAgICAgIHZhciBfcmV0O1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIF9yZXQgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoKF9yZXQgIT0gbnVsbCkpIHtcbiAgICAgICAgICB0aGlzLmRlbChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgfVxuXG4gICAgICB0dGwoa2V5LCB0dGwpIHtcbiAgICAgICAgdmFyIGVycjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICB0dGwgfHwgKHR0bCA9IHRoaXMub3B0aW9ucy5zdGRUVEwpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgZXhpc3RlbnQgZGF0YSBhbmQgdXBkYXRlIHRoZSB0dGwgdmFsdWVcbiAgICAgICAgaWYgKCh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKSkge1xuICAgICAgICAgIC8vIGlmIHR0bCA8IDAgZGVsZXRlIHRoZSBrZXkuIG90aGVyd2lzZSByZXNldCB0aGUgdmFsdWVcbiAgICAgICAgICBpZiAodHRsID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtrZXldID0gdGhpcy5fd3JhcCh0aGlzLmRhdGFba2V5XS52LCB0dGwsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmV0dXJuIGZhbHNlIGlmIGtleSBoYXMgbm90IGJlZW4gZm91bmRcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2V0VHRsKGtleSkge1xuICAgICAgICB2YXIgX3R0bCwgZXJyO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgZXhpc3RhbnQgZGF0YSBhbmQgdXBkYXRlIHRoZSB0dGwgdmFsdWVcbiAgICAgICAgaWYgKCh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKSkge1xuICAgICAgICAgIF90dGwgPSB0aGlzLmRhdGFba2V5XS50O1xuICAgICAgICAgIHJldHVybiBfdHRsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJldHVybiB1bmRlZmluZWQgaWYga2V5IGhhcyBub3QgYmVlbiBmb3VuZFxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAga2V5cygpIHtcbiAgICAgICAgdmFyIF9rZXlzO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIF9rZXlzID0gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICAgICAgcmV0dXJuIF9rZXlzO1xuICAgICAgfVxuXG4gICAgICBoYXMoa2V5KSB7XG4gICAgICAgIHZhciBfZXhpc3RzO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIF9leGlzdHMgPSAodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSk7XG4gICAgICAgIHJldHVybiBfZXhpc3RzO1xuICAgICAgfVxuXG4gICAgICBnZXRTdGF0cygpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0cztcbiAgICAgIH1cblxuICAgICAgZmx1c2hBbGwoX3N0YXJ0UGVyaW9kID0gdHJ1ZSkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIHBhcmFtZXRlciBqdXN0IGZvciB0ZXN0aW5nXG5cbiAgICAgICAgLy8gc2V0IGRhdGEgZW1wdHlcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIC8vIHJlc2V0IHN0YXRzXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAga2V5czogMCxcbiAgICAgICAgICBrc2l6ZTogMCxcbiAgICAgICAgICB2c2l6ZTogMFxuICAgICAgICB9O1xuICAgICAgICAvLyByZXNldCBjaGVjayBwZXJpb2RcbiAgICAgICAgdGhpcy5fa2lsbENoZWNrUGVyaW9kKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrRGF0YShfc3RhcnRQZXJpb2QpO1xuICAgICAgICB0aGlzLmVtaXQoXCJmbHVzaFwiKTtcbiAgICAgIH1cblxuICAgICAgZmx1c2hTdGF0cygpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyByZXNldCBzdGF0c1xuICAgICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgbWlzc2VzOiAwLFxuICAgICAgICAgIGtleXM6IDAsXG4gICAgICAgICAga3NpemU6IDAsXG4gICAgICAgICAgdnNpemU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmx1c2hfc3RhdHNcIik7XG4gICAgICB9XG5cbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHRoaXMuX2tpbGxDaGVja1BlcmlvZCgpO1xuICAgICAgfVxuXG4gICAgICBfY2hlY2tEYXRhKHN0YXJ0UGVyaW9kID0gdHJ1ZSkge1xuICAgICAgICB2YXIga2V5LCByZWYsIHZhbHVlO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHJlZiA9IHRoaXMuZGF0YTtcbiAgICAgICAgLy8gcnVuIHRoZSBob3VzZWtlZXBpbmcgbWV0aG9kXG4gICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgICAgdGhpcy5fY2hlY2soa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0UGVyaW9kICYmIHRoaXMub3B0aW9ucy5jaGVja3BlcmlvZCA+IDApIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fY2hlY2tEYXRhLCB0aGlzLm9wdGlvbnMuY2hlY2twZXJpb2QgKiAxMDAwLCBzdGFydFBlcmlvZCk7XG4gICAgICAgICAgaWYgKCh0aGlzLmNoZWNrVGltZW91dCAhPSBudWxsKSAmJiAodGhpcy5jaGVja1RpbWVvdXQudW5yZWYgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vICMjIF9raWxsQ2hlY2tQZXJpb2RcblxuICAgICAgLy8gc3RvcCB0aGUgY2hlY2tkYXRhIHBlcmlvZC4gT25seSBuZWVkZWQgdG8gYWJvcnQgdGhlIHNjcmlwdCBpbiB0ZXN0aW5nIG1vZGUuXG4gICAgICBfa2lsbENoZWNrUGVyaW9kKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja1RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQodGhpcy5jaGVja1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9jaGVjayhrZXksIGRhdGEpIHtcbiAgICAgICAgdmFyIF9yZXR2YWw7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX3JldHZhbCA9IHRydWU7XG4gICAgICAgIC8vIGRhdGEgaXMgaW52YWxpZCBpZiB0aGUgdHRsIGlzIHRvbyBvbGQgYW5kIGlzIG5vdCAwXG4gICAgICAgIC8vIGNvbnNvbGUubG9nIGRhdGEudCA8IERhdGUubm93KCksIGRhdGEudCwgRGF0ZS5ub3coKVxuICAgICAgICBpZiAoZGF0YS50ICE9PSAwICYmIGRhdGEudCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlbGV0ZU9uRXhwaXJlKSB7XG4gICAgICAgICAgICBfcmV0dmFsID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlbChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoXCJleHBpcmVkXCIsIGtleSwgdGhpcy5fdW53cmFwKGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JldHZhbDtcbiAgICAgIH1cblxuICAgICAgX2lzSW52YWxpZEtleShrZXkpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAocmVmID0gdHlwZW9mIGtleSwgaW5kZXhPZi5jYWxsKHRoaXMudmFsaWRLZXlUeXBlcywgcmVmKSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoXCJFS0VZVFlQRVwiLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlb2Yga2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3dyYXAodmFsdWUsIHR0bCwgYXNDbG9uZSA9IHRydWUpIHtcbiAgICAgICAgdmFyIGxpdmV0aW1lLCBub3csIG9SZXR1cm4sIHR0bE11bHRpcGxpY2F0b3I7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlQ2xvbmVzKSB7XG4gICAgICAgICAgYXNDbG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSB0aGUgdGltZSB0byBsaXZlXG4gICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxpdmV0aW1lID0gMDtcbiAgICAgICAgdHRsTXVsdGlwbGljYXRvciA9IDEwMDA7XG4gICAgICAgIC8vIHVzZSBnaXZlbiB0dGxcbiAgICAgICAgaWYgKHR0bCA9PT0gMCkge1xuICAgICAgICAgIGxpdmV0aW1lID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh0dGwpIHtcbiAgICAgICAgICBsaXZldGltZSA9IG5vdyArICh0dGwgKiB0dGxNdWx0aXBsaWNhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2Ugc3RhbmRhcmQgdHRsXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGRUVEwgPT09IDApIHtcbiAgICAgICAgICAgIGxpdmV0aW1lID0gdGhpcy5vcHRpb25zLnN0ZFRUTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGl2ZXRpbWUgPSBub3cgKyAodGhpcy5vcHRpb25zLnN0ZFRUTCAqIHR0bE11bHRpcGxpY2F0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gdGhlIHdyYXBwZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIG9SZXR1cm4gPSB7XG4gICAgICAgICAgdDogbGl2ZXRpbWUsXG4gICAgICAgICAgdjogYXNDbG9uZSA/IGNsb25lKHZhbHVlKSA6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vICMjIF91bndyYXBcblxuICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGV4dHJhY3QgZ2V0IHRoZSB2YWx1ZSBvdXQgb2YgdGhlIHdyYXBwZWQgdmFsdWVcbiAgICAgIF91bndyYXAodmFsdWUsIGFzQ2xvbmUgPSB0cnVlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZUNsb25lcykge1xuICAgICAgICAgIGFzQ2xvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFzQ2xvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZSh2YWx1ZS52KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyAjIyBfZ2V0S2V5TGVuZ3RoXG5cbiAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0aGUgY2FsY3VsYXRlIHRoZSBrZXkgbGVuZ3RoXG4gICAgICBfZ2V0S2V5TGVuZ3RoKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBfZ2V0VmFsTGVuZ3RoKHZhbHVlKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBhIFN0cmluZyBnZXQgdGhlIHJlYWwgbGVuZ3RoXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VTdHJpbmcpIHtcbiAgICAgICAgICAvLyBmb3JjZSBzdHJpbmcgaWYgaXQncyBkZWZpbmVkIGFuZCBub3QgcGFzc2VkXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBhbiBBcnJheSBtdWx0aXBseSBlYWNoIGVsZW1lbnQgd2l0aCBhIGRlZmluZWQgZGVmYXVsdCBsZW5ndGhcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFycmF5VmFsdWVTaXplICogdmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRoZW4gOiB2b2lkIDApID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBhIFByb21pc2UsIHVzZSBkZWZpbmVkIGRlZmF1bHRcbiAgICAgICAgICAvLyAoY2FuJ3QgY2FsY3VsYXRlIGFjdHVhbC9yZXNvbHZlZCB2YWx1ZSBzaXplIHN5bmNocm9ub3VzbHkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wcm9taXNlVmFsdWVTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgQnVmZmVyICE9PSBudWxsID8gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSA6IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoKHZhbHVlICE9IG51bGwpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGlzIGFuIE9iamVjdCBtdWx0aXBseSBlYWNoIGVsZW1lbnQgd2l0aCBhIGRlZmluZWQgZGVmYXVsdCBsZW5ndGhcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9iamVjdFZhbHVlU2l6ZSAqIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmF1bHQgZmFsbGJhY2tcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZXJyb3IodHlwZSwgZGF0YSA9IHt9KSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGVycm9yLm5hbWUgPSB0eXBlO1xuICAgICAgICBlcnJvci5lcnJvcmNvZGUgPSB0eXBlO1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gdGhpcy5FUlJPUlNbdHlwZV0gIT0gbnVsbCA/IHRoaXMuRVJST1JTW3R5cGVdKGRhdGEpIDogXCItXCI7XG4gICAgICAgIGVycm9yLmRhdGEgPSBkYXRhO1xuICAgICAgICAvLyByZXR1cm4gdGhlIGVycm9yIG9iamVjdFxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIF9pbml0RXJyb3JzKCkge1xuICAgICAgICB2YXIgX2Vyck1zZywgX2VyclQsIHJlZjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICB0aGlzLkVSUk9SUyA9IHt9O1xuICAgICAgICByZWYgPSB0aGlzLl9FUlJPUlM7XG4gICAgICAgIGZvciAoX2VyclQgaW4gcmVmKSB7XG4gICAgICAgICAgX2Vyck1zZyA9IHJlZltfZXJyVF07XG4gICAgICAgICAgdGhpcy5FUlJPUlNbX2VyclRdID0gdGhpcy5jcmVhdGVFcnJvck1lc3NhZ2UoX2Vyck1zZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3JlYXRlRXJyb3JNZXNzYWdlKGVyck1zZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHJldHVybiBlcnJNc2cucmVwbGFjZShcIl9fa2V5XCIsIGFyZ3MudHlwZSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgTm9kZUNhY2hlLnByb3RvdHlwZS5fRVJST1JTID0ge1xuICAgICAgXCJFTk9URk9VTkRcIjogXCJLZXkgYF9fa2V5YCBub3QgZm91bmRcIixcbiAgICAgIFwiRUNBQ0hFRlVMTFwiOiBcIkNhY2hlIG1heCBrZXlzIGFtb3VudCBleGNlZWRlZFwiLFxuICAgICAgXCJFS0VZVFlQRVwiOiBcIlRoZSBrZXkgYXJndW1lbnQgaGFzIHRvIGJlIG9mIHR5cGUgYHN0cmluZ2Agb3IgYG51bWJlcmAuIEZvdW5kOiBgX19rZXlgXCIsXG4gICAgICBcIkVLRVlTVFlQRVwiOiBcIlRoZSBrZXlzIGFyZ3VtZW50IGhhcyB0byBiZSBhbiBhcnJheS5cIixcbiAgICAgIFwiRVRUTFRZUEVcIjogXCJUaGUgdHRsIGFyZ3VtZW50IGhhcyB0byBiZSBhIG51bWJlci5cIlxuICAgIH07XG5cbiAgICByZXR1cm4gTm9kZUNhY2hlO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/node-cache@5.1.2/node_modules/node-cache/lib/node_cache.js\n");

/***/ })

};
;